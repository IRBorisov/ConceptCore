// AsciiLexerImpl.hpp generated by reflex 4.4.0 from AsciiLexerImpl.l

#define REFLEX_VERSION "4.4.0"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_nodefault
#undef REFLEX_OPTION_noindent
#undef REFLEX_OPTION_noline
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_token_type

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               AsciiLexerImpl
#define REFLEX_OPTION_namespace           ccl::rslang::detail::asciilex
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noindent            true
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "AsciiLexerImpl.hpp"
#define REFLEX_OPTION_token_type          ccl::rslang::TokenID

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////



#pragma once
#include "ccl/rslang/RSToken.h"



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define WITH_NO_INDENT
#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ccl {
namespace rslang {
namespace detail {
namespace asciilex {

class AsciiLexerImpl : public reflex::AbstractLexer<reflex::Matcher> {

public:
  [[nodiscard]] StrRange Range() const {
   // Note: returning byte position, not code point! Assume input is ASCII
    return StrRange{
        static_cast<StrPos>(matcher().first()),
        static_cast<StrPos>(matcher().last())
    };
  }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  AsciiLexerImpl(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // the lexer function defined by SECTION 2
  virtual ccl::rslang::TokenID lex(void);
  // lexer functions accepting new input to scan
  ccl::rslang::TokenID lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  ccl::rslang::TokenID lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace ccl
} // namespace rslang
} // namespace detail
} // namespace asciilex

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ccl {
namespace rslang {
namespace detail {
namespace asciilex {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ccl
} // namespace rslang
} // namespace detail
} // namespace asciilex

ccl::rslang::TokenID ccl::rslang::detail::asciilex::AsciiLexerImpl::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
{ return TokenID::END; }
            }
            else
            {
              lexer_error("scanner jammed");
              return ccl::rslang::TokenID();
            }
            break;
          case 1: // rule AsciiLexerImpl.l:47: "\A" :
{ return TokenID::FORALL; }
            break;
          case 2: // rule AsciiLexerImpl.l:48: "\E" :
{ return TokenID::EXISTS; }

            break;
          case 3: // rule AsciiLexerImpl.l:50: "\neg" :
{ return TokenID::NOT; }
            break;
          case 4: // rule AsciiLexerImpl.l:51: "\and" :
{ return TokenID::AND; }
            break;
          case 5: // rule AsciiLexerImpl.l:52: "\or" :
{ return TokenID::OR; }
            break;
          case 6: // rule AsciiLexerImpl.l:53: "\impl" :
{ return TokenID::IMPLICATION; }
            break;
          case 7: // rule AsciiLexerImpl.l:54: "\equiv" :
{ return TokenID::EQUIVALENT; }

            break;
          case 8: // rule AsciiLexerImpl.l:56: "\plus" :
{ return TokenID::PLUS; }
            break;
          case 9: // rule AsciiLexerImpl.l:57: "\minus" :
{ return TokenID::MINUS; }
            break;
          case 10: // rule AsciiLexerImpl.l:58: "\multiply" :
{ return TokenID::MULTIPLY; }
            break;
          case 11: // rule AsciiLexerImpl.l:59: "\gr" :
{ return TokenID::GREATER; }
            break;
          case 12: // rule AsciiLexerImpl.l:60: "\ls" :
{ return TokenID::LESSER; }
            break;
          case 13: // rule AsciiLexerImpl.l:61: "\ge" :
{ return TokenID::GREATER_OR_EQ; }
            break;
          case 14: // rule AsciiLexerImpl.l:62: "\le" :
{ return TokenID::LESSER_OR_EQ; }

            break;
          case 15: // rule AsciiLexerImpl.l:64: "\eq" :
{ return TokenID::EQUAL; }
            break;
          case 16: // rule AsciiLexerImpl.l:65: "\noteq" :
{ return TokenID::NOTEQUAL; }

            break;
          case 17: // rule AsciiLexerImpl.l:67: "\in" :
{ return TokenID::IN; }
            break;
          case 18: // rule AsciiLexerImpl.l:68: "\notin" :
{ return TokenID::NOTIN; }
            break;
          case 19: // rule AsciiLexerImpl.l:69: "\subseteq" :
{ return TokenID::SUBSET_OR_EQ; }
            break;
          case 20: // rule AsciiLexerImpl.l:70: "\subset" :
{ return TokenID::SUBSET; }
            break;
          case 21: // rule AsciiLexerImpl.l:71: "\notsubset" :
{ return TokenID::NOTSUBSET; }

            break;
          case 22: // rule AsciiLexerImpl.l:73: "*" :
{ return TokenID::DECART; }
            break;
          case 23: // rule AsciiLexerImpl.l:74: "\union" :
{ return TokenID::UNION; }
            break;
          case 24: // rule AsciiLexerImpl.l:75: "\intersect" :
{ return TokenID::INTERSECTION; }
            break;
          case 25: // rule AsciiLexerImpl.l:76: "\setminus" :
{ return TokenID::SET_MINUS; }
            break;
          case 26: // rule AsciiLexerImpl.l:77: "\symmdiff" :
{ return TokenID::SYMMINUS; }
            break;
          case 27: // rule AsciiLexerImpl.l:78: "B" :
{ return TokenID::BOOLEAN; }

            break;
          case 28: // rule AsciiLexerImpl.l:80: pr{index} :
{ return TokenID::SMALLPR; }
            break;
          case 29: // rule AsciiLexerImpl.l:81: Pr{index} :
{ return TokenID::BIGPR; }
            break;
          case 30: // rule AsciiLexerImpl.l:82: Fi{index} :
{ return TokenID::FILTER; }
            break;
          case 31: // rule AsciiLexerImpl.l:83: card :
{ return TokenID::CARD; }
            break;
          case 32: // rule AsciiLexerImpl.l:84: bool :
{ return TokenID::BOOL; }
            break;
          case 33: // rule AsciiLexerImpl.l:85: red :
{ return TokenID::REDUCE; }
            break;
          case 34: // rule AsciiLexerImpl.l:86: debool :
{ return TokenID::DEBOOL; }

            break;
          case 35: // rule AsciiLexerImpl.l:88: D :
{ return TokenID::DECLARATIVE; }
            break;
          case 36: // rule AsciiLexerImpl.l:89: R :
{ return TokenID::RECURSIVE; }
            break;
          case 37: // rule AsciiLexerImpl.l:90: I :
{ return TokenID::IMPERATIVE; }

            break;
          case 38: // rule AsciiLexerImpl.l:92: Z :
{ return TokenID::LIT_INTSET; }
            break;
          case 39: // rule AsciiLexerImpl.l:93: "{}" :
{ return TokenID::LIT_EMPTYSET; }
            break;
          case 40: // rule AsciiLexerImpl.l:94: {number} :
{ return TokenID::LIT_INTEGER; }

            break;
          case 41: // rule AsciiLexerImpl.l:96: F{number} :
{ return TokenID::ID_FUNCTION; }
            break;
          case 42: // rule AsciiLexerImpl.l:97: P{number} :
{ return TokenID::ID_PREDICATE; }
            break;
          case 43: // rule AsciiLexerImpl.l:98: R{number} :
{ return TokenID::ID_RADICAL; }

            break;
          case 44: // rule AsciiLexerImpl.l:100: {global_id} :
{ return TokenID::ID_GLOBAL; }
            break;
          case 45: // rule AsciiLexerImpl.l:101: {local_id} :
{ return TokenID::ID_LOCAL; }

            break;
          case 46: // rule AsciiLexerImpl.l:103: "\assign" :
{ return TokenID::ASSIGN; }
            break;
          case 47: // rule AsciiLexerImpl.l:104: "\from" :
{ return TokenID::ITERATE; }
            break;
          case 48: // rule AsciiLexerImpl.l:105: "\defexpr" :
{ return TokenID::PUNC_DEFINE; }
            break;
          case 49: // rule AsciiLexerImpl.l:106: "\deftype" :
{ return TokenID::PUNC_STRUCT; }
            break;
          case 50: // rule AsciiLexerImpl.l:107: "(" :
{ return TokenID::PUNC_PL; }
            break;
          case 51: // rule AsciiLexerImpl.l:108: ")" :
{ return TokenID::PUNC_PR; }
            break;
          case 52: // rule AsciiLexerImpl.l:109: "{" :
{ return TokenID::PUNC_CL; }
            break;
          case 53: // rule AsciiLexerImpl.l:110: "}" :
{ return TokenID::PUNC_CR; }
            break;
          case 54: // rule AsciiLexerImpl.l:111: "[" :
{ return TokenID::PUNC_SL; }
            break;
          case 55: // rule AsciiLexerImpl.l:112: "]" :
{ return TokenID::PUNC_SR; }
            break;
          case 56: // rule AsciiLexerImpl.l:113: "|" :
{ return TokenID::PUNC_BAR; }
            break;
          case 57: // rule AsciiLexerImpl.l:114: "," :
{ return TokenID::PUNC_COMMA; }
            break;
          case 58: // rule AsciiLexerImpl.l:115: ";" :
{ return TokenID::PUNC_SEMICOLON; }

            break;
          case 59: // rule AsciiLexerImpl.l:117: {ws} :
;
            break;
          case 60: // rule AsciiLexerImpl.l:119: . :
{ return TokenID::INTERRUPT; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ccl {
namespace rslang {
namespace detail {
namespace asciilex {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c = 0;
  m.FSM_INIT(c);

S0:
  m.FSM_FIND();
  c = m.FSM_CHAR();
  if (c == '}') goto S148;
  if (c == '|') goto S154;
  if (c == '{') goto S126;
  if (c == 'r') goto S88;
  if (c == 'p') goto S53;
  if (c == 'd') goto S95;
  if (c == 'c') goto S74;
  if (c == 'b') goto S81;
  if ('a' <= c && c <= 'z') goto S138;
  if (c == '_') goto S138;
  if (c == ']') goto S152;
  if (c == '\\') goto S32;
  if (c == '[') goto S150;
  if (c == 'Z') goto S120;
  if (c == 'R') goto S108;
  if (c == 'P') goto S60;
  if (c == 'I') goto S114;
  if (c == 'F') goto S67;
  if (c == 'D') goto S102;
  if (c == 'B') goto S51;
  if ('A' <= c && c <= 'Y') goto S132;
  if (c == ';') goto S158;
  if ('0' <= c && c <= '9') goto S129;
  if (c == ',') goto S156;
  if (c == '*') goto S49;
  if (c == ')') goto S146;
  if (c == '(') goto S144;
  if (c == ' ') goto S165;
  if (c == '\r') goto S165;
  if (c == '\n') goto S160;
  if (c == '\t') goto S165;
  if (0 <= c) goto S170;
  return m.FSM_HALT(c);

S32:
  m.FSM_TAKE(60);
  c = m.FSM_CHAR();
  if (c == 'u') goto S204;
  if (c == 's') goto S200;
  if (c == 'p') goto S189;
  if (c == 'o') goto S182;
  if (c == 'n') goto S176;
  if (c == 'm') goto S191;
  if (c == 'l') goto S197;
  if (c == 'i') goto S184;
  if (c == 'g') goto S194;
  if (c == 'f') goto S206;
  if (c == 'e') goto S187;
  if (c == 'd') goto S208;
  if (c == 'a') goto S179;
  if (c == 'E') goto S174;
  if (c == 'A') goto S172;
  return m.FSM_HALT(c);

S49:
  m.FSM_TAKE(22);
  return m.FSM_HALT();

S51:
  m.FSM_TAKE(27);
  return m.FSM_HALT();

S53:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'r') goto S210;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S60:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if (c == 'r') goto S222;
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S228;
  return m.FSM_HALT(c);

S67:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if (c == 'i') goto S240;
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S246;
  return m.FSM_HALT(c);

S74:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if ('b' <= c && c <= 'z') goto S216;
  if (c == 'a') goto S252;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S81:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'o') goto S259;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S88:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'e') goto S266;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S95:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'e') goto S273;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S102:
  m.FSM_TAKE(35);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S234;
  return m.FSM_HALT(c);

S108:
  m.FSM_TAKE(36);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S280;
  return m.FSM_HALT(c);

S114:
  m.FSM_TAKE(37);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S234;
  return m.FSM_HALT(c);

S120:
  m.FSM_TAKE(38);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S234;
  return m.FSM_HALT(c);

S126:
  m.FSM_TAKE(52);
  c = m.FSM_CHAR();
  if (c == '}') goto S286;
  return m.FSM_HALT(c);

S129:
  m.FSM_TAKE(40);
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S288;
  return m.FSM_HALT(c);

S132:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S234;
  return m.FSM_HALT(c);

S138:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S144:
  m.FSM_TAKE(50);
  return m.FSM_HALT();

S146:
  m.FSM_TAKE(51);
  return m.FSM_HALT();

S148:
  m.FSM_TAKE(53);
  return m.FSM_HALT();

S150:
  m.FSM_TAKE(54);
  return m.FSM_HALT();

S152:
  m.FSM_TAKE(55);
  return m.FSM_HALT();

S154:
  m.FSM_TAKE(56);
  return m.FSM_HALT();

S156:
  m.FSM_TAKE(57);
  return m.FSM_HALT();

S158:
  m.FSM_TAKE(58);
  return m.FSM_HALT();

S160:
  m.FSM_TAKE(59);
  c = m.FSM_CHAR();
  if (c == ' ') goto S160;
  if (c == '\r') goto S160;
  if ('\t' <= c && c <= '\n') goto S160;
  return m.FSM_HALT(c);

S165:
  m.FSM_TAKE(59);
  c = m.FSM_CHAR();
  if (c == ' ') goto S160;
  if (c == '\r') goto S160;
  if ('\t' <= c && c <= '\n') goto S160;
  return m.FSM_HALT(c);

S170:
  m.FSM_TAKE(60);
  return m.FSM_HALT();

S172:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S174:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S176:
  c = m.FSM_CHAR();
  if (c == 'o') goto S293;
  if (c == 'e') goto S291;
  return m.FSM_HALT(c);

S179:
  c = m.FSM_CHAR();
  if (c == 's') goto S297;
  if (c == 'n') goto S295;
  return m.FSM_HALT(c);

S182:
  c = m.FSM_CHAR();
  if (c == 'r') goto S299;
  return m.FSM_HALT(c);

S184:
  c = m.FSM_CHAR();
  if (c == 'n') goto S303;
  if (c == 'm') goto S301;
  return m.FSM_HALT(c);

S187:
  c = m.FSM_CHAR();
  if (c == 'q') goto S306;
  return m.FSM_HALT(c);

S189:
  c = m.FSM_CHAR();
  if (c == 'l') goto S309;
  return m.FSM_HALT(c);

S191:
  c = m.FSM_CHAR();
  if (c == 'u') goto S313;
  if (c == 'i') goto S311;
  return m.FSM_HALT(c);

S194:
  c = m.FSM_CHAR();
  if (c == 'r') goto S315;
  if (c == 'e') goto S317;
  return m.FSM_HALT(c);

S197:
  c = m.FSM_CHAR();
  if (c == 's') goto S319;
  if (c == 'e') goto S321;
  return m.FSM_HALT(c);

S200:
  c = m.FSM_CHAR();
  if (c == 'y') goto S327;
  if (c == 'u') goto S323;
  if (c == 'e') goto S325;
  return m.FSM_HALT(c);

S204:
  c = m.FSM_CHAR();
  if (c == 'n') goto S329;
  return m.FSM_HALT(c);

S206:
  c = m.FSM_CHAR();
  if (c == 'r') goto S331;
  return m.FSM_HALT(c);

S208:
  c = m.FSM_CHAR();
  if (c == 'e') goto S333;
  return m.FSM_HALT(c);

S210:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S335;
  return m.FSM_HALT(c);

S216:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S222:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S342;
  return m.FSM_HALT(c);

S228:
  m.FSM_TAKE(42);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S228;
  return m.FSM_HALT(c);

S234:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S234;
  return m.FSM_HALT(c);

S240:
  m.FSM_TAKE(44);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S349;
  return m.FSM_HALT(c);

S246:
  m.FSM_TAKE(41);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S246;
  return m.FSM_HALT(c);

S252:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'r') goto S356;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S259:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'o') goto S363;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S266:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'd') goto S370;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S273:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'b') goto S376;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S280:
  m.FSM_TAKE(43);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S280;
  return m.FSM_HALT(c);

S286:
  m.FSM_TAKE(39);
  return m.FSM_HALT();

S288:
  m.FSM_TAKE(40);
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S288;
  return m.FSM_HALT(c);

S291:
  c = m.FSM_CHAR();
  if (c == 'g') goto S383;
  return m.FSM_HALT(c);

S293:
  c = m.FSM_CHAR();
  if (c == 't') goto S385;
  return m.FSM_HALT(c);

S295:
  c = m.FSM_CHAR();
  if (c == 'd') goto S389;
  return m.FSM_HALT(c);

S297:
  c = m.FSM_CHAR();
  if (c == 's') goto S391;
  return m.FSM_HALT(c);

S299:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S301:
  c = m.FSM_CHAR();
  if (c == 'p') goto S393;
  return m.FSM_HALT(c);

S303:
  m.FSM_TAKE(17);
  c = m.FSM_CHAR();
  if (c == 't') goto S395;
  return m.FSM_HALT(c);

S306:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'u') goto S397;
  return m.FSM_HALT(c);

S309:
  c = m.FSM_CHAR();
  if (c == 'u') goto S399;
  return m.FSM_HALT(c);

S311:
  c = m.FSM_CHAR();
  if (c == 'n') goto S401;
  return m.FSM_HALT(c);

S313:
  c = m.FSM_CHAR();
  if (c == 'l') goto S403;
  return m.FSM_HALT(c);

S315:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S317:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S319:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S321:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S323:
  c = m.FSM_CHAR();
  if (c == 'b') goto S405;
  return m.FSM_HALT(c);

S325:
  c = m.FSM_CHAR();
  if (c == 't') goto S407;
  return m.FSM_HALT(c);

S327:
  c = m.FSM_CHAR();
  if (c == 'm') goto S409;
  return m.FSM_HALT(c);

S329:
  c = m.FSM_CHAR();
  if (c == 'i') goto S411;
  return m.FSM_HALT(c);

S331:
  c = m.FSM_CHAR();
  if (c == 'o') goto S413;
  return m.FSM_HALT(c);

S333:
  c = m.FSM_CHAR();
  if (c == 'f') goto S415;
  return m.FSM_HALT(c);

S335:
  m.FSM_TAKE(28);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S335;
  if (c == ',') goto S418;
  return m.FSM_HALT(c);

S342:
  m.FSM_TAKE(29);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S342;
  if (c == ',') goto S420;
  return m.FSM_HALT(c);

S349:
  m.FSM_TAKE(30);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S234;
  if (c == '_') goto S234;
  if ('A' <= c && c <= 'Z') goto S234;
  if ('0' <= c && c <= '9') goto S349;
  if (c == ',') goto S422;
  return m.FSM_HALT(c);

S356:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'd') goto S424;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S363:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'l') goto S430;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S370:
  m.FSM_TAKE(33);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S376:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'o') goto S436;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S383:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S385:
  c = m.FSM_CHAR();
  if (c == 's') goto S447;
  if (c == 'i') goto S445;
  if (c == 'e') goto S443;
  return m.FSM_HALT(c);

S389:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S391:
  c = m.FSM_CHAR();
  if (c == 'i') goto S449;
  return m.FSM_HALT(c);

S393:
  c = m.FSM_CHAR();
  if (c == 'l') goto S451;
  return m.FSM_HALT(c);

S395:
  c = m.FSM_CHAR();
  if (c == 'e') goto S453;
  return m.FSM_HALT(c);

S397:
  c = m.FSM_CHAR();
  if (c == 'i') goto S455;
  return m.FSM_HALT(c);

S399:
  c = m.FSM_CHAR();
  if (c == 's') goto S457;
  return m.FSM_HALT(c);

S401:
  c = m.FSM_CHAR();
  if (c == 'u') goto S459;
  return m.FSM_HALT(c);

S403:
  c = m.FSM_CHAR();
  if (c == 't') goto S461;
  return m.FSM_HALT(c);

S405:
  c = m.FSM_CHAR();
  if (c == 's') goto S463;
  return m.FSM_HALT(c);

S407:
  c = m.FSM_CHAR();
  if (c == 'm') goto S465;
  return m.FSM_HALT(c);

S409:
  c = m.FSM_CHAR();
  if (c == 'm') goto S467;
  return m.FSM_HALT(c);

S411:
  c = m.FSM_CHAR();
  if (c == 'o') goto S469;
  return m.FSM_HALT(c);

S413:
  c = m.FSM_CHAR();
  if (c == 'm') goto S471;
  return m.FSM_HALT(c);

S415:
  c = m.FSM_CHAR();
  if (c == 't') goto S475;
  if (c == 'e') goto S473;
  return m.FSM_HALT(c);

S418:
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S477;
  return m.FSM_HALT(c);

S420:
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S481;
  return m.FSM_HALT(c);

S422:
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S485;
  return m.FSM_HALT(c);

S424:
  m.FSM_TAKE(31);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S430:
  m.FSM_TAKE(32);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S436:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'o') goto S489;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S443:
  c = m.FSM_CHAR();
  if (c == 'q') goto S496;
  return m.FSM_HALT(c);

S445:
  c = m.FSM_CHAR();
  if (c == 'n') goto S498;
  return m.FSM_HALT(c);

S447:
  c = m.FSM_CHAR();
  if (c == 'u') goto S500;
  return m.FSM_HALT(c);

S449:
  c = m.FSM_CHAR();
  if (c == 'g') goto S502;
  return m.FSM_HALT(c);

S451:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S453:
  c = m.FSM_CHAR();
  if (c == 'r') goto S504;
  return m.FSM_HALT(c);

S455:
  c = m.FSM_CHAR();
  if (c == 'v') goto S506;
  return m.FSM_HALT(c);

S457:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S459:
  c = m.FSM_CHAR();
  if (c == 's') goto S508;
  return m.FSM_HALT(c);

S461:
  c = m.FSM_CHAR();
  if (c == 'i') goto S510;
  return m.FSM_HALT(c);

S463:
  c = m.FSM_CHAR();
  if (c == 'e') goto S512;
  return m.FSM_HALT(c);

S465:
  c = m.FSM_CHAR();
  if (c == 'i') goto S514;
  return m.FSM_HALT(c);

S467:
  c = m.FSM_CHAR();
  if (c == 'd') goto S516;
  return m.FSM_HALT(c);

S469:
  c = m.FSM_CHAR();
  if (c == 'n') goto S518;
  return m.FSM_HALT(c);

S471:
  m.FSM_TAKE(47);
  return m.FSM_HALT();

S473:
  c = m.FSM_CHAR();
  if (c == 'x') goto S520;
  return m.FSM_HALT(c);

S475:
  c = m.FSM_CHAR();
  if (c == 'y') goto S522;
  return m.FSM_HALT(c);

S477:
  m.FSM_TAKE(28);
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S477;
  if (c == ',') goto S418;
  return m.FSM_HALT(c);

S481:
  m.FSM_TAKE(29);
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S481;
  if (c == ',') goto S420;
  return m.FSM_HALT(c);

S485:
  m.FSM_TAKE(30);
  c = m.FSM_CHAR();
  if ('0' <= c && c <= '9') goto S485;
  if (c == ',') goto S422;
  return m.FSM_HALT(c);

S489:
  m.FSM_TAKE(45);
  c = m.FSM_CHAR();
  if (c == 'l') goto S524;
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S496:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S498:
  m.FSM_TAKE(18);
  return m.FSM_HALT();

S500:
  c = m.FSM_CHAR();
  if (c == 'b') goto S530;
  return m.FSM_HALT(c);

S502:
  c = m.FSM_CHAR();
  if (c == 'n') goto S532;
  return m.FSM_HALT(c);

S504:
  c = m.FSM_CHAR();
  if (c == 's') goto S534;
  return m.FSM_HALT(c);

S506:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S508:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S510:
  c = m.FSM_CHAR();
  if (c == 'p') goto S536;
  return m.FSM_HALT(c);

S512:
  c = m.FSM_CHAR();
  if (c == 't') goto S538;
  return m.FSM_HALT(c);

S514:
  c = m.FSM_CHAR();
  if (c == 'n') goto S541;
  return m.FSM_HALT(c);

S516:
  c = m.FSM_CHAR();
  if (c == 'i') goto S543;
  return m.FSM_HALT(c);

S518:
  m.FSM_TAKE(23);
  return m.FSM_HALT();

S520:
  c = m.FSM_CHAR();
  if (c == 'p') goto S545;
  return m.FSM_HALT(c);

S522:
  c = m.FSM_CHAR();
  if (c == 'p') goto S547;
  return m.FSM_HALT(c);

S524:
  m.FSM_TAKE(34);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S216;
  if (c == '_') goto S216;
  if ('A' <= c && c <= 'Z') goto S216;
  if ('0' <= c && c <= '9') goto S216;
  return m.FSM_HALT(c);

S530:
  c = m.FSM_CHAR();
  if (c == 's') goto S549;
  return m.FSM_HALT(c);

S532:
  m.FSM_TAKE(46);
  return m.FSM_HALT();

S534:
  c = m.FSM_CHAR();
  if (c == 'e') goto S551;
  return m.FSM_HALT(c);

S536:
  c = m.FSM_CHAR();
  if (c == 'l') goto S553;
  return m.FSM_HALT(c);

S538:
  m.FSM_TAKE(20);
  c = m.FSM_CHAR();
  if (c == 'e') goto S555;
  return m.FSM_HALT(c);

S541:
  c = m.FSM_CHAR();
  if (c == 'u') goto S557;
  return m.FSM_HALT(c);

S543:
  c = m.FSM_CHAR();
  if (c == 'f') goto S559;
  return m.FSM_HALT(c);

S545:
  c = m.FSM_CHAR();
  if (c == 'r') goto S561;
  return m.FSM_HALT(c);

S547:
  c = m.FSM_CHAR();
  if (c == 'e') goto S563;
  return m.FSM_HALT(c);

S549:
  c = m.FSM_CHAR();
  if (c == 'e') goto S565;
  return m.FSM_HALT(c);

S551:
  c = m.FSM_CHAR();
  if (c == 'c') goto S567;
  return m.FSM_HALT(c);

S553:
  c = m.FSM_CHAR();
  if (c == 'y') goto S569;
  return m.FSM_HALT(c);

S555:
  c = m.FSM_CHAR();
  if (c == 'q') goto S571;
  return m.FSM_HALT(c);

S557:
  c = m.FSM_CHAR();
  if (c == 's') goto S573;
  return m.FSM_HALT(c);

S559:
  c = m.FSM_CHAR();
  if (c == 'f') goto S575;
  return m.FSM_HALT(c);

S561:
  m.FSM_TAKE(48);
  return m.FSM_HALT();

S563:
  m.FSM_TAKE(49);
  return m.FSM_HALT();

S565:
  c = m.FSM_CHAR();
  if (c == 't') goto S577;
  return m.FSM_HALT(c);

S567:
  c = m.FSM_CHAR();
  if (c == 't') goto S579;
  return m.FSM_HALT(c);

S569:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S571:
  m.FSM_TAKE(19);
  return m.FSM_HALT();

S573:
  m.FSM_TAKE(25);
  return m.FSM_HALT();

S575:
  m.FSM_TAKE(26);
  return m.FSM_HALT();

S577:
  m.FSM_TAKE(21);
  return m.FSM_HALT();

S579:
  m.FSM_TAKE(24);
  return m.FSM_HALT();
}

} // namespace ccl

} // namespace rslang

} // namespace detail

} // namespace asciilex

