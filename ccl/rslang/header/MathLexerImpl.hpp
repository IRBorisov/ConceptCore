// MathLexerImpl.hpp generated by reflex 4.2.1 from MathLexerImpl.l

#define REFLEX_VERSION "4.2.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_nodefault
#undef REFLEX_OPTION_noindent
#undef REFLEX_OPTION_noline
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_tabs
#undef REFLEX_OPTION_token_type
#undef REFLEX_OPTION_unicode

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               MathLexerImpl
#define REFLEX_OPTION_namespace           ccl::rslang::detail::rslex
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noindent            true
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "MathLexerImpl.hpp"
#define REFLEX_OPTION_tabs                1
#define REFLEX_OPTION_token_type          ccl::rslang::TokenID
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////



#pragma once
#include "ccl/rslang/RSToken.h"



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define WITH_NO_INDENT
#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ccl {
namespace rslang {
namespace detail {
namespace rslex {

class MathLexerImpl : public reflex::AbstractLexer<reflex::Matcher> {

public:
  StrPos lineBase{ 0 };

  [[nodiscard]] StrRange Range() const {
    return StrRange{
        static_cast<StrPos>(lineBase + columno()),
        static_cast<StrPos>(lineBase + columno() + columns())
    };
  }


 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  MathLexerImpl(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // the lexer function defined by SECTION 2
  virtual ccl::rslang::TokenID lex(void);
  // lexer functions accepting new input to scan
  ccl::rslang::TokenID lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  ccl::rslang::TokenID lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace ccl
} // namespace rslang
} // namespace detail
} // namespace rslex

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ccl {
namespace rslang {
namespace detail {
namespace rslex {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ccl
} // namespace rslang
} // namespace detail
} // namespace rslex

ccl::rslang::TokenID ccl::rslang::detail::rslex::MathLexerImpl::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this, "T=1"));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
{ return TokenID::END; }
            }
            else
            {
              lexer_error("scanner jammed");
              return ccl::rslang::TokenID();
            }
            break;
          case 1: // rule MathLexerImpl.l:50: "+" :
{ return TokenID::PLUS; }
            break;
          case 2: // rule MathLexerImpl.l:51: "-" :
{ return TokenID::MINUS; }
            break;
          case 3: // rule MathLexerImpl.l:52: "*" :
{ return TokenID::MULTIPLY; }
            break;
          case 4: // rule MathLexerImpl.l:53: ">" :
{ return TokenID::GREATER; }
            break;
          case 5: // rule MathLexerImpl.l:54: "<" :
{ return TokenID::LESSER; }
            break;
          case 6: // rule MathLexerImpl.l:55: \x{2265} :
{ return TokenID::GREATER_OR_EQ; }
            break;
          case 7: // rule MathLexerImpl.l:56: \x{2264} :
{ return TokenID::LESSER_OR_EQ; }

            break;
          case 8: // rule MathLexerImpl.l:58: "=" :
{ return TokenID::EQUAL; }
            break;
          case 9: // rule MathLexerImpl.l:59: \x{2260} :
{ return TokenID::NOTEQUAL; }

            break;
          case 10: // rule MathLexerImpl.l:61: \x{2200} :
{ return TokenID::FORALL; }
            break;
          case 11: // rule MathLexerImpl.l:62: \x{2203} :
{ return TokenID::EXISTS; }

            break;
          case 12: // rule MathLexerImpl.l:64: \x{00AC} :
{ return TokenID::NOT; }
            break;
          case 13: // rule MathLexerImpl.l:65: "&" :
{ return TokenID::AND; }
            break;
          case 14: // rule MathLexerImpl.l:66: \x{2228} :
{ return TokenID::OR; }
            break;
          case 15: // rule MathLexerImpl.l:67: \x{21D2} :
{ return TokenID::IMPLICATION; }
            break;
          case 16: // rule MathLexerImpl.l:68: \x{21D4} :
{ return TokenID::EQUIVALENT; }

            break;
          case 17: // rule MathLexerImpl.l:70: :\x{2208} :
{ return TokenID::ITERATE; }
            break;
          case 18: // rule MathLexerImpl.l:71: \x{2208} :
{ return TokenID::IN; }
            break;
          case 19: // rule MathLexerImpl.l:72: \x{2209} :
{ return TokenID::NOTIN; }
            break;
          case 20: // rule MathLexerImpl.l:73: \x{2286} :
{ return TokenID::SUBSET_OR_EQ; }
            break;
          case 21: // rule MathLexerImpl.l:74: \x{2282} :
{ return TokenID::SUBSET; }
            break;
          case 22: // rule MathLexerImpl.l:75: \x{2284} :
{ return TokenID::NOTSUBSET; }

            break;
          case 23: // rule MathLexerImpl.l:77: \x{00D7} :
{ return TokenID::DECART; }
            break;
          case 24: // rule MathLexerImpl.l:78: \x{222A} :
{ return TokenID::UNION; }
            break;
          case 25: // rule MathLexerImpl.l:79: \x{2229} :
{ return TokenID::INTERSECTION; }
            break;
          case 26: // rule MathLexerImpl.l:80: \x{005C} :
{ return TokenID::SET_MINUS; }
            break;
          case 27: // rule MathLexerImpl.l:81: \x{2206} :
{ return TokenID::SYMMINUS; }
            break;
          case 28: // rule MathLexerImpl.l:82: \x{212C} :
{ return TokenID::BOOLEAN; }

            break;
          case 29: // rule MathLexerImpl.l:84: pr{index} :
{ return TokenID::SMALLPR; }
            break;
          case 30: // rule MathLexerImpl.l:85: Pr{index} :
{ return TokenID::BIGPR; }
            break;
          case 31: // rule MathLexerImpl.l:86: Fi{index} :
{ return TokenID::FILTER; }
            break;
          case 32: // rule MathLexerImpl.l:87: card :
{ return TokenID::CARD; }
            break;
          case 33: // rule MathLexerImpl.l:88: bool :
{ return TokenID::BOOL; }
            break;
          case 34: // rule MathLexerImpl.l:89: red :
{ return TokenID::REDUCE; }
            break;
          case 35: // rule MathLexerImpl.l:90: debool :
{ return TokenID::DEBOOL; }

            break;
          case 36: // rule MathLexerImpl.l:92: D :
{ return TokenID::DECLARATIVE; }
            break;
          case 37: // rule MathLexerImpl.l:93: R :
{ return TokenID::RECURSIVE; }
            break;
          case 38: // rule MathLexerImpl.l:94: I :
{ return TokenID::IMPERATIVE; }

            break;
          case 39: // rule MathLexerImpl.l:96: Z :
{ return TokenID::LIT_INTSET; }
            break;
          case 40: // rule MathLexerImpl.l:97: \x{2205} :
{ return TokenID::LIT_EMPTYSET; }
            break;
          case 41: // rule MathLexerImpl.l:98: {number} :
{ return TokenID::LIT_INTEGER; }

            break;
          case 42: // rule MathLexerImpl.l:100: F{number} :
{ return TokenID::ID_FUNCTION; }
            break;
          case 43: // rule MathLexerImpl.l:101: P{number} :
{ return TokenID::ID_PREDICATE; }
            break;
          case 44: // rule MathLexerImpl.l:102: R{number} :
{ return TokenID::ID_RADICAL; }

            break;
          case 45: // rule MathLexerImpl.l:104: {global_id} :
{ return TokenID::ID_GLOBAL; }
            break;
          case 46: // rule MathLexerImpl.l:105: {local_id} :
{ return TokenID::ID_LOCAL; }

            break;
          case 47: // rule MathLexerImpl.l:107: ":=" :
{ return TokenID::ASSIGN; }
            break;
          case 48: // rule MathLexerImpl.l:108: ":==" :
{ return TokenID::PUNC_DEFINE; }
            break;
          case 49: // rule MathLexerImpl.l:109: "::=" :
{ return TokenID::PUNC_STRUCT; }
            break;
          case 50: // rule MathLexerImpl.l:110: "(" :
{ return TokenID::PUNC_PL; }
            break;
          case 51: // rule MathLexerImpl.l:111: ")" :
{ return TokenID::PUNC_PR; }
            break;
          case 52: // rule MathLexerImpl.l:112: "{" :
{ return TokenID::PUNC_CL; }
            break;
          case 53: // rule MathLexerImpl.l:113: "}" :
{ return TokenID::PUNC_CR; }
            break;
          case 54: // rule MathLexerImpl.l:114: "[" :
{ return TokenID::PUNC_SL; }
            break;
          case 55: // rule MathLexerImpl.l:115: "]" :
{ return TokenID::PUNC_SR; }
            break;
          case 56: // rule MathLexerImpl.l:116: "|" :
{ return TokenID::PUNC_BAR; }
            break;
          case 57: // rule MathLexerImpl.l:117: "," :
{ return TokenID::PUNC_COMMA; }
            break;
          case 58: // rule MathLexerImpl.l:118: ";" :
{ return TokenID::PUNC_SEMICOLON; }

            break;
          case 59: // rule MathLexerImpl.l:120: \n :
{ lineBase += static_cast<StrPos>(columno() + 1); }
            break;
          case 60: // rule MathLexerImpl.l:121: [ \t]+ :
;
            break;
          case 61: // rule MathLexerImpl.l:123: . :
{ return TokenID::INTERRUPT; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ccl {
namespace rslang {
namespace detail {
namespace rslex {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 226) goto S58;
  if (c1 == 207) goto S221;
  if (c1 == 206) goto S217;
  if (c1 == 195) goto S82;
  if (c1 == 194) goto S69;
  if (c1 == '}') goto S234;
  if (c1 == '|') goto S243;
  if (c1 == '{') goto S231;
  if (c1 == 'r') goto S139;
  if (c1 == 'p') goto S89;
  if (c1 == 'd') goto S149;
  if (c1 == 'c') goto S119;
  if (c1 == 'b') goto S129;
  if ('a' <= c1 && c1 <= 'z') goto S208;
  if (c1 == '_') goto S208;
  if (c1 == ']') goto S240;
  if (c1 == '\\') goto S86;
  if (c1 == '[') goto S237;
  if (c1 == 'Z') goto S186;
  if (c1 == 'R') goto S168;
  if (c1 == 'P') goto S99;
  if (c1 == 'I') goto S177;
  if (c1 == 'F') goto S109;
  if (c1 == 'D') goto S159;
  if ('C' <= c1 && c1 <= 'Y') goto S199;
  if (c1 == 'A') goto S199;
  if (c1 == '>') goto S52;
  if (c1 == '=') goto S66;
  if (c1 == '<') goto S55;
  if (c1 == ';') goto S249;
  if (c1 == ':') goto S76;
  if ('0' <= c1 && c1 <= '9') goto S195;
  if (c1 == '-') goto S46;
  if (c1 == ',') goto S246;
  if (c1 == '+') goto S43;
  if (c1 == '*') goto S49;
  if (c1 == ')') goto S228;
  if (c1 == '(') goto S225;
  if (c1 == '&') goto S73;
  if (c1 == ' ') goto S254;
  if (c1 == '\n') goto S252;
  if (c1 == '\t') goto S254;
  if (0 <= c1) goto S259;
  return m.FSM_HALT(c1);

S43:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S46:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S49:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S52:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S55:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S58:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 138) goto S285;
  if (c1 == 137) goto S262;
  if (c1 == 136) goto S268;
  if (c1 == 135) goto S280;
  if (c1 == 132) goto S291;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S66:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S69:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 172) goto S295;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S73:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S76:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 226) goto S298;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == '=') goto S300;
  if (c1 == ':') goto S303;
  return m.FSM_HALT(c1);

S82:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 151) goto S305;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S86:
  m.FSM_TAKE(26);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S89:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'r') goto S308;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S99:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'r') goto S328;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S336;
  return m.FSM_HALT(c1);

S109:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'i') goto S356;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S364;
  return m.FSM_HALT(c1);

S119:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('b' <= c1 && c1 <= 'z') goto S316;
  if (c1 == 'a') goto S372;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S129:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'o') goto S381;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S139:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'e') goto S390;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S149:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == 'e') goto S399;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S159:
  m.FSM_TAKE(36);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S344;
  return m.FSM_HALT(c1);

S168:
  m.FSM_TAKE(37);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S408;
  return m.FSM_HALT(c1);

S177:
  m.FSM_TAKE(38);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S344;
  return m.FSM_HALT(c1);

S186:
  m.FSM_TAKE(39);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S344;
  return m.FSM_HALT(c1);

S195:
  m.FSM_TAKE(41);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('0' <= c1 && c1 <= '9') goto S416;
  return m.FSM_HALT(c1);

S199:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S344;
  return m.FSM_HALT(c1);

S208:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (128 <= c1 && c1 <= 191) goto S259;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S217:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (177 <= c1 && c1 <= 191) goto S208;
  if (128 <= c1 && c1 <= 176) goto S259;
  return m.FSM_HALT(c1);

S221:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (138 <= c1 && c1 <= 191) goto S259;
  if (128 <= c1 && c1 <= 137) goto S208;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(50);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S228:
  m.FSM_TAKE(51);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S231:
  m.FSM_TAKE(52);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S234:
  m.FSM_TAKE(53);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S237:
  m.FSM_TAKE(54);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S240:
  m.FSM_TAKE(55);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S243:
  m.FSM_TAKE(56);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S246:
  m.FSM_TAKE(57);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S249:
  m.FSM_TAKE(58);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S252:
  m.FSM_TAKE(59);
  return m.FSM_HALT();

S254:
  m.FSM_TAKE(60);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  if (c1 == ' ') goto S419;
  if (c1 == '\t') goto S419;
  return m.FSM_HALT(c1);

S259:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S262:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 165) goto S423;
  if (c1 == 164) goto S426;
  if (c1 == 160) goto S429;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S268:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 170) goto S447;
  if (c1 == 169) goto S450;
  if (c1 == 168) goto S438;
  if (c1 == 137) goto S444;
  if (c1 == 136) goto S441;
  if (c1 == 134) goto S453;
  if (c1 == 133) goto S456;
  if (c1 == 131) goto S435;
  if (129 <= c1 && c1 <= 191) goto S259;
  if (c1 == 128) goto S432;
  return m.FSM_HALT(c1);

S280:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 148) goto S462;
  if (c1 == 146) goto S459;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S285:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 134) goto S465;
  if (c1 == 132) goto S471;
  if (c1 == 130) goto S468;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S291:
  m.FSM_TAKE(61);
  c1 = m.FSM_CHAR();
  if (c1 == 172) goto S474;
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S295:
  m.FSM_TAKE(12);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S298:
  c1 = m.FSM_CHAR();
  if (c1 == 136) goto S477;
  return m.FSM_HALT(c1);

S300:
  m.FSM_TAKE(47);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S479;
  return m.FSM_HALT(c1);

S303:
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S481;
  return m.FSM_HALT(c1);

S305:
  m.FSM_TAKE(23);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S308:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S483;
  return m.FSM_HALT(c1);

S316:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S324:
  c1 = m.FSM_CHAR();
  if (177 <= c1 && c1 <= 191) goto S316;
  return m.FSM_HALT(c1);

S326:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 137) goto S316;
  return m.FSM_HALT(c1);

S328:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S492;
  return m.FSM_HALT(c1);

S336:
  m.FSM_TAKE(43);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S336;
  return m.FSM_HALT(c1);

S344:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S344;
  return m.FSM_HALT(c1);

S352:
  c1 = m.FSM_CHAR();
  if (177 <= c1 && c1 <= 191) goto S344;
  return m.FSM_HALT(c1);

S354:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 137) goto S344;
  return m.FSM_HALT(c1);

S356:
  m.FSM_TAKE(45);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S501;
  return m.FSM_HALT(c1);

S364:
  m.FSM_TAKE(42);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S364;
  return m.FSM_HALT(c1);

S372:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'r') goto S510;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S381:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'o') goto S519;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S390:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'd') goto S528;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S399:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'b') goto S536;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S408:
  m.FSM_TAKE(44);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S408;
  return m.FSM_HALT(c1);

S416:
  m.FSM_TAKE(41);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S416;
  return m.FSM_HALT(c1);

S419:
  m.FSM_TAKE(60);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S419;
  if (c1 == '\t') goto S419;
  return m.FSM_HALT(c1);

S423:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S426:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S429:
  m.FSM_TAKE(9);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S432:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S435:
  m.FSM_TAKE(11);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S438:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S441:
  m.FSM_TAKE(18);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S444:
  m.FSM_TAKE(19);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S447:
  m.FSM_TAKE(24);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S450:
  m.FSM_TAKE(25);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S453:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S456:
  m.FSM_TAKE(40);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S459:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S462:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S465:
  m.FSM_TAKE(20);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S468:
  m.FSM_TAKE(21);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S471:
  m.FSM_TAKE(22);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S474:
  m.FSM_TAKE(28);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S259;
  return m.FSM_HALT(c1);

S477:
  c1 = m.FSM_CHAR();
  if (c1 == 136) goto S545;
  return m.FSM_HALT(c1);

S479:
  m.FSM_TAKE(48);
  return m.FSM_HALT();

S481:
  m.FSM_TAKE(49);
  return m.FSM_HALT();

S483:
  m.FSM_TAKE(29);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S483;
  if (c1 == ',') goto S547;
  return m.FSM_HALT(c1);

S492:
  m.FSM_TAKE(30);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S492;
  if (c1 == ',') goto S549;
  return m.FSM_HALT(c1);

S501:
  m.FSM_TAKE(31);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S354;
  if (c1 == 206) goto S352;
  if ('a' <= c1 && c1 <= 'z') goto S344;
  if (c1 == '_') goto S344;
  if ('A' <= c1 && c1 <= 'Z') goto S344;
  if ('0' <= c1 && c1 <= '9') goto S501;
  if (c1 == ',') goto S551;
  return m.FSM_HALT(c1);

S510:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'd') goto S553;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S519:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'l') goto S561;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S528:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S536:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'o') goto S569;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S545:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S547:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S578;
  return m.FSM_HALT(c1);

S549:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S582;
  return m.FSM_HALT(c1);

S551:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S586;
  return m.FSM_HALT(c1);

S553:
  m.FSM_TAKE(32);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S561:
  m.FSM_TAKE(33);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S569:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'o') goto S590;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S578:
  m.FSM_TAKE(29);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S578;
  if (c1 == ',') goto S547;
  return m.FSM_HALT(c1);

S582:
  m.FSM_TAKE(30);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S582;
  if (c1 == ',') goto S549;
  return m.FSM_HALT(c1);

S586:
  m.FSM_TAKE(31);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S586;
  if (c1 == ',') goto S551;
  return m.FSM_HALT(c1);

S590:
  m.FSM_TAKE(46);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if (c1 == 'l') goto S599;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);

S599:
  m.FSM_TAKE(35);
  c1 = m.FSM_CHAR();
  if (c1 == 207) goto S326;
  if (c1 == 206) goto S324;
  if ('a' <= c1 && c1 <= 'z') goto S316;
  if (c1 == '_') goto S316;
  if ('A' <= c1 && c1 <= 'Z') goto S316;
  if ('0' <= c1 && c1 <= '9') goto S316;
  return m.FSM_HALT(c1);
}

} // namespace ccl

} // namespace rslang

} // namespace detail

} // namespace rslex

